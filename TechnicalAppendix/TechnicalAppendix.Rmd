---
title: "Technical Appendix"
author: 'ST344 Team 5'
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
install.packages("devtools", repos = "http://cran.us.r-project.org")
library(devtools)
source_url("https://raw.github.com/timleeman/ST344GroupProject/main/setup.R")

```
```{r}
library(readr)
install.packages("devtools", repos = "http://cran.us.r-project.org")
library(devtools)
source_url("https://raw.github.com/timleeman/ST344GroupProject/main/getdata.R")
```

#Setup and Data

## Explaining setup scripts

The `setup.R` script installs packages as follows:
```{r, eval = FALSE}
install.packages("dplyr", "remotes", "lubridate", "readxl", "rio", "ggpubr", lib = Sys.getenv("R_LIBS_USER"), repos = "http://cran.us.r-project.org") 
install.packages("tidyverse")
remotes::install_github("nset-ornl/wbstats")
remotes::install_github("joachim-gassen/tidycovid19")
library(tidyverse)
library(dplyr)
library(remotes)
library(lubridate)
library(readxl)
library(rio)
library(tidycovid19)
library(ggpubr)
library(zoo)
```

The `getdata.R` script downloads the data we are using from our shared github repository, as well as produces a list of countries which we have chosen to analyse:
```{r, eval = FALSE}
library(readr)
install.packages("devtools", repos = "http://cran.us.r-project.org")
library(devtools)
#Reads the tidied version of the AuraVision dataset for lockdown dates
auravisionData <- read_csv("https://raw.github.com/timleeman/ST344GroupProject/main/Data/AuraVisionCleaned.csv")
#Imports a tibble which lists which continent of all of the countries
countries <- read_csv("https://raw.github.com/timleeman/ST344GroupProject/main/Data/Continents.csv")
#Imports a snapshot of the merged tidycovid19 data set created on 19/11/2020
covidData <- read_csv("https://raw.github.com/timleeman/ST344GroupProject/main/Data/TidyCovid19DataSet.csv", guess_max = 10000)

#Next section adds continent to the covidData dataset so we can filter out countries in continents we are not interested in
countries <- filter(countries, country %in% covidData$country)
covidData <- left_join(covidData, countries, by = "country")
covidData <- mutate(covidData, country = factor(country), continent = factor(continent))
covidData$country <- as.factor(covidData$country)
#Getting just the relevant continents
covidData <- filter(covidData, continent == "Europe" | continent == "North America" | continent == "South America" | country == "Turkey")
#These for loops get rid of countries which have more than a third of their Google Mobility Trends data missing
co <- ""
#Remove countries with excessive amounts of data missing in gcmr_retail_recreation column
for (co in levels(covidData$country)){
  #100 can be changed to another threshold
  if(sum(is.na(filter(covidData, country == co)$gcmr_retail_recreation)) >= 100){
    covidData <- filter(covidData, country != co)
  }
}

#Remove countries with excessive amounts of data missing in gcmr_grocery_pharmacy column
for (co in levels(covidData$country)){
  #100 can be changed to another threshold
  if(sum(is.na(filter(covidData, country == co)$gcmr_grocery_pharmacy)) >= 100){
    covidData <- filter(covidData, country != co)
  }
}
#Getting rid of countries with populations less than 1,000,000
covidData <- filter(covidData, population > 1000000)
#Now, we get the remaining countries and then get the tidycovid19 data set again, so we have the full data but a list of countries we can filter it on also.
covidData <- droplevels(covidData)
chosenCountries <- levels(covidData$country)
covidData <- read_csv("https://raw.github.com/timleeman/ST344GroupProject/main/Data/TidyCovid19DataSet.csv", guess_max = 10000)
countries <- filter(countries, country %in% covidData$country)
covidData <- left_join(covidData, countries, by = "country")
covidData <- mutate(covidData, country = factor(country), continent = factor(continent))
```

## Cleaning the Auravision Dataset

We rely on a data set from AuraVision which includes start and end dates of various types of lockdowns across countries for much of our analysis. The data set was originally messy and what follows is the procedure for tidying it.

First we get the original version of the AuraVision Dataset.
```{r getolddata, eval = FALSE}
auravisionData <- read_csv("https://raw.github.com/timleeman/ST344GroupProject/main/LockdownDates/AuravisionLockdownDates.csv")
```

Then we filter on our chosen countries, as defined by the getdata.R setup script.
```{r filteringChosenCountries, eval = FALSE}
auravisionData <- auravisionData %>% filter(Country %in% chosenCountries)
```

### Cleaning our dataset

We rename our columns using CamelBack font type, with the first character capital. We did this to remove all spaces within variable names.
```{r renameColumns, eval = FALSE}
auravisionData <- rename(auravisionData, StartDate = 'Start date', EndDate = 'End date')
```

We do not make much use of non-national (e.g. city-wide or regional) lockdowns for our investigation. Therefore, we focussed our efforts on cleaning the rows of our dataset that pertain to national lockdowns.

Here, we check for countries with National lockdowns that have a missing start or end date. 
```{r missingEndDate, eval = FALSE}
auravisionData %>% filter(Level=='National' & (is.na(StartDate) | is.na(EndDate)))
```
After doing some (brief) research online, it seems that Panama is still in lockdown. Therefore, we can accept this missing end date; it is the result of an unknown end date, and not a missing data value.

Then, we check for countries with multiple National lockdowns reported in the dataset.

```{r findMultipleRows, eval = FALSE}
auravisionData %>% 
  filter(Level=='National') %>%
  group_by(Country) %>%
  filter(n()>1) %>%
  arrange(Country, StartDate)
```
### Honduras
The Honduras had a slightly staggered lockdown. Four municipalities implemented a lockdown and then within less than a week the rest of the country also went into lockdown. We shall be taking using the row in our dataset that refers to the country as a whole (and not to Place=="Rest of area")

### Mexico
After doing some (brief) research online, it seems that Mexico City remained in lockdown after the end of the national lockdown. The date at which the majority of the country's lockdown ended was 2020-06-01. Therefore we choose this as our end date.

### Turkey
The source for Turkey's 'second' national lockdown (i.e. Place=="Turkey(second implementation)") is no longer available. As it only spans four days, this may not have been a significant impact on the variables we are observing, therefore we shall ignore this row in our dataset.
Turkey's 'first' national lockdown (i.e. Place=="Turkey(first implementation)") also only spans two days. Therefore, for the same reasons, we dismiss this row and only observe the row where the variable 'Place' is missing.

```{r cleanMultipleRows, eval = FALSE}
# These are the rows for national lockdowns that we want, for our three countries with multiple national lockdowns in the AuraVision dataset.
auravisionData %>%
  filter((Country=='Honduras' & is.na(Place)) |
           (Country=='Mexico' & !is.na(Place)) |
           (Country=='Turkey' & is.na(Place)))

auravisionData <- subset(auravisionData,
       (!Country %in% c("Honduras", "Mexico", "Turkey")) | # Take any rows if not in our three countries.
         Level != 'National' | # Take any rows if not related to a national lockdown.
         (Country=='Honduras' & is.na(Place)) |
         (Country=='Mexico' & !is.na(Place)) |
         (Country=='Turkey' & is.na(Place))) %>% arrange(Country)

```

### Exporting .csv file

Finally, we export this as a .csv so that it can be easily used by the whole team.
```{r, eval = FALSE}
write_csv(auravisionData, "AuraVisionCleaned.csv", na="")
```

This `.csv` of the tidied dataset was then uploaded to our github repository [here](https://github.com/timleeman/ST344GroupProject/blob/main/Data/AuraVisionCleaned.csv)




#Analysis


## Investigating effect of Lockdowns


```{r setting up functions}
firstdiff <- function(x) {                 
  shifted <- c(0,x[1:(length(x)-1)])
  result = x-shifted
  which_negative = which(result<0)
  result[which_negative] = NA
  return(result)
}
```

```{r getting OWID Data https://github.com/owid/covid-19-data/blob/master/public/data/README.md}
OWIDdata<- read.csv('https://covid.ourworldindata.org/data/owid-covid-data.csv')
```

```{r setting up dataframe, , warning = FALSE, message = FALSE}
covidData1<- covidData %>% filter(country %in% chosenCountries)

covidData1<- covidData1%>% 
  mutate(national_lock = ifelse(country %in% filter(auravisionData, Level == 'National')$Country, 1, 0))%>% 
  mutate(city_lock = ifelse(country %in% filter(auravisionData, Level == 'City')$Country, 1, 0))%>%
  mutate(region_lock = ifelse(country %in% filter(auravisionData, Level %in% c('Prefecture','Province','State','Region','Regional'))$Country, 1, 0))%>%
  mutate(confirmed_per_capita = confirmed/population) %>%
  mutate(daily_confirmed = firstdiff(confirmed)) %>%
  mutate(daily_deaths = firstdiff(deaths)) %>%
  mutate(deaths_per_capita = deaths/population)%>% 
  mutate(income = factor(income, levels = c("High income","Upper middle income", "Lower middle income", "Low income")))

```

```{r setting up OWIDdata}
OWIDdata1<- OWIDdata %>% 
  rename(country = location) %>%
  filter(country %in% chosenCountries) %>%
  select(date, country, reproduction_rate) 

OWIDdata1 <- OWIDdata1 %>%
  mutate(date = as.Date(parse_date_time(OWIDdata1$date, orders = 'ymd')))

covidData1<- right_join(covidData1, OWIDdata1, by = c('country','date'))
```

```{r effects of national lockdown on retail and recreation, , warning = FALSE, message = FALSE}
plot_1<- filter(covidData1, national_lock %in% 1) %>%
  ggplot(aes(x = date, y = gcmr_retail_recreation)) +
  geom_line(aes(y = rollmean(gcmr_retail_recreation, 7, na.pad = TRUE)), colour = 'red', alpha= 0.3)+
  geom_smooth(aes(colour = 'Coutries with National Lockdowns'), data = filter(covidData1, national_lock %in% 1), se = FALSE)+
  geom_line(aes(y = rollmean(gcmr_retail_recreation, 7, na.pad = TRUE)), colour = 'blue', alpha= 0.3, data = filter(covidData1, national_lock %in% 0))+
  geom_smooth(aes(colour = 'Countries without National Lockdowns'), data = filter(covidData1, national_lock %in% 0), se = FALSE)+
  scale_colour_manual(name = 'Legend', values = c('Coutries with National Lockdowns'='red','Countries without National Lockdowns' = 'blue' ))+
  labs(title = 'Effects of a National Lockdown on Retail and Recreation', x= "Date", y = 'Activity in Retail and Recreation Centres') + 
  scale_x_date(breaks = 'months', date_labels = '%b')+
  theme(title = element_text(size = 20, hjust = 0.5, face = 'bold'), axis.title.x = element_text(size = 20), legend.text = element_text(size = 20))
```

```{r effects of national lockdown on grocery and pharmacy, , warning = FALSE, message = FALSE}
plot_2<- filter(covidData1, national_lock %in% 1) %>%
  ggplot(aes(x = date, y = gcmr_grocery_pharmacy)) +
  geom_line(aes(y = rollmean(gcmr_grocery_pharmacy, 7, na.pad = TRUE)), colour = 'red', alpha= 0.3)+
  geom_smooth(aes(colour = 'Coutries with National Lockdowns'), data = filter(covidData1, national_lock %in% 1), se = FALSE)+
  geom_line(aes(y = rollmean(gcmr_grocery_pharmacy, 7, na.pad = TRUE)), colour = 'blue', alpha= 0.3, data = filter(covidData1, national_lock %in% 0))+
  geom_smooth(aes(colour = 'Countries without National Lockdowns'), data = filter(covidData1, national_lock %in% 0), se = FALSE)+
  scale_colour_manual(name = 'Legend', values = c('Coutries with National Lockdowns'='red','Countries without National Lockdowns' = 'blue' ))+
  labs(title = 'Effects of a National Lockdown on Groceries and Pharmacies', x= "Date", y = 'Activity in Groceries and Pharmacies')+ 
  scale_x_date(breaks = 'months', date_labels = '%b')+
  theme(title = element_text(size = 20, hjust = 0.5, face = 'bold'), axis.title.x = element_text(size = 20), legend.text = element_text(size = 20))
```


```{r arranging the plots, fig.height = 10, fig.width= 15, warning = FALSE, message = FALSE}
plot_final<- ggarrange(plot_1, plot_2,ncol = 2, nrow = 1)
plot_final
```
From the 2 plots above, we can see that with the presence of a national lockdown on our list of chosen countries, the level of activity in gcmr_retail_recreation and gcmr_grocery_pharmacy have decreased dramatically compared to countries without a lockdown. This suggests that a national lockdown does hamper economic activity and thus affects the businesses by decreasing the number of customers.

```{r}
firstStageModelRetail <- lm(gcmr_retail_recreation ~ national_lock + confirmed_per_capita + daily_deaths, data = covidData2)
summary(firstStageModelRetail)
anova(firstStageModelRetail)
```

```{r glm for gcmr_reatail_recreation}
minModel <- glm(data = na.omit(covidData1), gcmr_retail_recreation ~ 1)
maxModel <- glm(data = na.omit(covidData1), gcmr_retail_recreation ~national_lock + confirmed_per_capita + daily_deaths + deaths_per_capita + daily_confirmed)
autoBack <- step(maxModel, direction = "backward", scope = list("lower" = minModel))
autoForward <- step(minModel, direction = "forward", scope = list("upper" = maxModel))
autoBoth <- step(minModel, direction = "both", scope = list("lower" = minModel, "upper" = maxModel))
#Final model
model_1<- glm(data = na.omit(covidData1), gcmr_retail_recreation ~ national_lock + daily_deaths + daily_confirmed)
summary(model_1)
```

```{r glm for gcmr_grocery_pharmacy}
minModel <- glm(data = na.omit(covidData1), gcmr_grocery_pharmacy ~ 1)
maxModel <- glm(data = na.omit(covidData1), gcmr_grocery_pharmacy ~national_lock + confirmed_per_capita + daily_deaths + deaths_per_capita + daily_confirmed)
autoBack <- step(maxModel, direction = "backward", scope = list("lower" = minModel))
autoForward <- step(minModel, direction = "forward", scope = list("upper" = maxModel))
autoBoth <- step(minModel, direction = "both", scope = list("lower" = minModel, "upper" = maxModel))
#Final model
model_2<- glm(data = na.omit(covidData1), gcmr_grocery_pharmacy~national_lock + daily_deaths + deaths_per_capita + daily_confirmed)
summary(model_2)
```

```{r plots of confirmed or death against date with colour as reproduction rate}
covidData1 %>% ggplot(aes(x = date, y = daily_confirmed, colour = reproduction_rate))+
  geom_point(alpha = 0.5, size = 0.5)+
  scale_colour_gradient(low = 'yellow', high = 'red', na.value = NA)+
  ggtitle('Daily confirmed')

covidData1 %>% ggplot(aes(x = date, y = daily_deaths, colour = reproduction_rate))+
  geom_point(alpha = 0.5, size = 0.5)+
  scale_colour_gradient(low = 'yellow', high = 'red', na.value = NA)+
  ggtitle('Daily Deaths')

covidData1 %>% ggplot(aes(x = date, y = confirmed, colour = reproduction_rate))+
  geom_point(alpha = 0.5, size = 0.5)+
  scale_colour_gradient(low = 'yellow', high = 'red', na.value = NA)+
  ggtitle('Confirmed')

covidData1 %>% ggplot(aes(x = date, y = deaths, colour = reproduction_rate))+
  geom_point(alpha = 0.5, size = 0.5)+
  scale_colour_gradient(low = 'yellow', high = 'red', na.value = NA)+
  ggtitle('Deaths')
```

```{r glm for confirmed}
minModel <- glm(data = na.omit(covidData1), confirmed ~ 1)
maxModel <- glm(data = na.omit(covidData1), confirmed ~national_lock + reproduction_rate)
autoBack <- step(maxModel, direction = "backward", scope = list("lower" = minModel))
autoForward <- step(minModel, direction = "forward", scope = list("upper" = maxModel))
autoBoth <- step(minModel, direction = "both", scope = list("lower" = minModel, "upper" = maxModel))

#Final Model
model_3<- glm(data = na.omit(covidData1), confirmed ~ national_lock + reproduction_rate)
summary(model_3)
```

## Investigating the effect of length of lockdown

The data for each country has been divided into their pre, intra and post lockdown dates. This used the functions `pre_lockdown_start date`, `lockdown_end_date` and `get_lockdown_data` and then each individual country's data was binded together. This was done using the Auravision data and then a rolling mean was calculated 
using the 3days before and after a specific day. This method means that although we were looking at data from a week before, the mean could only be calculated from four days before the start of lockdown and stopped three days before the end.
```{r, include = FALSE}
source_url("https://raw.github.com/timleeman/ST344GroupProject/main/getdata.R")
```

```{r libraries, include=FALSE}
covidData$date = as.Date(parse_date_time(covidData$date,orders=c("y","ym","ymd")))
TidyData <- covidData %>% group_by(country) 
TidyData <- mutate(TidyData, country = factor(country), continent = factor(continent))
```
# Getting the length of each country's lockdown from Auravision
```{r lockdown_length calculator,}
national_lockdowns <- auravisionData %>% filter(Level== "National") %>% select(-Level)
national_lockdowns <- national_lockdowns %>% mutate(national_lockdown_length = as.numeric(-difftime(`StartDate`, `EndDate`)))
colnames(national_lockdowns)[1] = "country"
national_lockdowns <- filter(national_lockdowns, country %in% chosenCountries)
head(national_lockdowns %>% select(country, national_lockdown_length) %>% arrange(national_lockdown_length),60)
```

# These series of function pull the relevant dates from Auravision and countries from covidData. 
# In order to compare countries, we aligned each country's data to the start of lockdown by creating the variable `days_in_lockdown`.
# We also agreed to use a rolling mean for gcmr to reduce the effect of daily variations. 
# The mean is calculated by averaging the gcmr of the three days before and after a specific day.

```{r functions_to_get_lockdown_data_and_bind,}
selectData <- filter(covidData, country %in% chosenCountries)
#Function to select country
pre_lockdown_start_date <- function(cou){
  a <- national_lockdowns %>% filter(country == cou) %>% select(`StartDate`)
  return(a$`StartDate`[1] - 7) 
}
lockdown_start_date <- function(cou){
  a <- national_lockdowns %>% filter(country == cou) %>% select(`StartDate`)
  return(a$`StartDate`[1]) 
}
lockdown_end_date <- function(cou){
  a <- national_lockdowns %>% filter(country == cou) %>% select(`EndDate`)
  return(a$`EndDate`[1]) 
}
get_lockdown_data <- function(cou){
  lockdown_data <- selectData %>% filter(country == cou) %>% 
                    filter(date >= pre_lockdown_start_date(cou)) %>%
                    filter(date < lockdown_end_date(cou)) %>%
                    mutate(days_in_lockdown = as.numeric(-difftime(lockdown_start_date(cou), date)/86400),
                           rolling_gcmr_retail = zoo::rollmean(gcmr_retail_recreation, k = 7, fill = NA),
                           rolling_gcmr_grocery = zoo::rollmean(gcmr_grocery_pharmacy, k = 7, fill = NA))
  return(lockdown_data)
}
lockdown_data <- tibble()
for(cou in national_lockdowns$country){
  a <- get_lockdown_data(cou)
  lockdown_data <- rbind(a, lockdown_data)
}
```

```{r calculating_the_r, message=FALSE, warning=FALSE}

#We calculated the R number for three periods in each country's epidemic 

#The first function uses the 28 days leading up to lockdown, it returns NA for countries that had a maximum of 10 daily cases during the period because the high R's calculated were not justifiable
before_lockdown_r <- function(cou){
  startday <- lockdown_start_date(cou) - 28
  endday <- lockdown_start_date(cou)
  key_data <- selectData %>% dplyr::select(country, date, daily_confirmed) %>%
    filter(date >= startday & date < endday) %>% filter(country == cou) %>% na.omit()
  if(max(key_data$daily_confirmed) < 10){
    return(NA)
  }
  daily_cases_model <- glm.nb(daily_confirmed ~ 1 + date, data = key_data)
  key_data$pred_daily_cases <- predict(daily_cases_model)
  R <-  exp(4*(coef(daily_cases_model)[2] %>% as.numeric))
  return(R)
}


#The second R uses the 28 days from the day with the most cases in lockdown
during_lockdown_r <- function(cou){
  startday <- get_peak_daily_cases_day(cou)
  endday <- startday + 28
  key_data <- selectData %>% dplyr::select(country, date, daily_confirmed) %>%
    filter(date >= startday & date < endday) %>% filter(country == cou) %>% na.omit()
  daily_cases_model <- glm.nb(daily_confirmed ~ 1 + date, data = key_data)
  key_data$pred_daily_cases <- predict(daily_cases_model)
  R <-  exp(4*(coef(daily_cases_model)[2] %>% as.numeric))
  return(R)
}


#This uses the 7 days after lockdown. Some countries were still in lockdown at the end of the dataset so if a lockdown end date was not found from Auravision, we use the during lockdown functions result for continuity.
post_lockdown_r <- function(cou){
  if(is.na(lockdown_end_date(cou))){
    return(during_lockdown_r(cou))
  }
  startday <- lockdown_end_date(cou)
  endday <- startday + 7
  key_data <- selectData %>% dplyr::select(country, date, daily_confirmed) %>%
    filter(date > startday & date <= endday) %>% filter(country == cou) %>% na.omit()
  daily_cases_model <- glm.nb(daily_confirmed ~ 1 + date, data = key_data)
  key_data$pred_daily_cases <- predict(daily_cases_model)
  R <-  exp(4*(coef(daily_cases_model)[2] %>% as.numeric))
  return(R)
}

lst <- list(country= c(), before_lockdown_r= c(), during_lockdown_r= c(), post_lockdown_r= c())

Rdata <- as.data.frame(lst)


#Calculates the three R values 
calculate_r <- function(x){
  a <- before_lockdown_r(x) 
  b <- during_lockdown_r(x)
  c <- post_lockdown_r(x)
  row <- data.frame(country = x,
                  before_lockdown_r = a, 
                  during_lockdown_r = b,
                  post_lockdown_r = c)
  return(row)
}

# Binding the R data for each country in national lockdown
for(i in national_lockdowns$country){
  Rdata <- rbind(Rdata, calculate_r(i))
}


```

```{r exploring_Rdata,}

head(Rdata,45)
ggplot(Rdata, aes(x= before_lockdown_r)) + geom_boxplot() + 
  labs(x= "R", title= "Distribution of R before Lockdown",
       subtitle= "R calculated from the 28 days before lockdown") 
ggplot(Rdata, aes(x= during_lockdown_r)) + geom_boxplot() + 
  labs(x= "R", title= "Distribution of R from peak cases day",
       subtitle= "R calculated from the 28 days after the peak cases day in lockdown") 
ggplot(Rdata, aes(x= post_lockdown_r)) + geom_boxplot() + 
  labs(x= "R", title= "Distribution of R after Lockdown",
       subtitle= "R calculated from the 7 days after lockdown") 

```


```{r anaylsing_data,}
firstdiff <- function(x) {
  shifted <- c(0,x[1:(length(x)-1)])
  result = x-shifted
  which_negative = which(result<0)
  result[which_negative] = NA
  return(result) }
lockdown_data <- lockdown_data %>%
  mutate(daily_confirmed = firstdiff(confirmed))
head(lockdown_data,100)
```

# This section adds data from Gapminder and Statista that we suscepted would be relevant to gcmr models

```{r model_data,}
average_temperature <- import("https://raw.github.com/timleeman/ST344GroupProject/main/Modelling/average_temperature_edit.xlsx")
modelData <- lockdown_data %>% select(country, date, continent, gdp_capita, rolling_gcmr_retail, 
                                      rolling_gcmr_grocery, gcmr_retail_recreation, gcmr_grocery_pharmacy, days_in_lockdown, income) %>%  distinct()
modelData <- left_join(modelData, average_temperature, by= "country")

modelData$gdp_capita <- scale(modelData$gdp_capita)
#modelData$average_temperature <- scale(modelData$average_temperature)
modelData <- modelData %>% na.omit() 
modelData <- modelData %>% mutate(days_squared = days_in_lockdown^2)
population_20_39 <- import("https://raw.github.com/timleeman/ST344GroupProject/main/Modelling/population_aged_20_39.xlsx")
population_20_39 <- select(population_20_39, country, `2019`)
population_40_59 <- import("https://raw.github.com/timleeman/ST344GroupProject/main/Modelling/population_aged_40_59.xlsx")
population_40_59 <- select(population_40_59, country, `2019`)
population_20_59 <- left_join(population_20_39, population_40_59, by= "country")
population_20_59 <- population_20_59 %>% transmute(country, pop_20_59= `2019.x` + `2019.y` )
modelData <- left_join(modelData, population_20_59, by= "country")
head(modelData,500)
```

# View plots of gcmr against days in lockdown to assess the validating of a model. 

```{r justification_for_first_model,}
plot_country_lockdown_gcmr_retail <- function(cou){
  a <- modelData %>% filter(country == cou)
  ggplot(a, aes(x= date, y= rolling_gcmr_retail)) + geom_line()
}
#plot_country_lockdown_gcmr_retail("Germany")
ggplot(modelData, aes(x=days_in_lockdown, y= rolling_gcmr_retail, group= country, col= average_temperature)) + geom_line()
ggplot(modelData, aes(x=days_in_lockdown, y= rolling_gcmr_retail, group= country, col= income)) + geom_line()
ggplot(modelData, aes(x=days_in_lockdown, y= rolling_gcmr_retail, group= country, col= pop_20_59)) + geom_line()
```

# The basic first model

```{r first_model,}
model1 <- lm(data= modelData, rolling_gcmr_retail ~ days_in_lockdown)
summary(model1)
```

# We started off by categorising countries into short, medium and long lockdown lengths but we realised that this could make the findings of the investigation highly subject to manipulations.

```{r grouping_by_lockdown_length, warning=FALSE}
ggplot(national_lockdowns, aes(x= national_lockdown_length)) +
geom_histogram(breaks= seq(0,160,25)) 
#average_lockdown_length <- national_lockdowns %>% filter(national_lockdown_length <= 77 & national_lockdown_length > 48)
#average_lockdown_modelData <- modelData %>% filter(country %in% average_lockdown_length$country)
#next bit just adds a new variable lockdown category to national_lockdowns based on proposed lengths
lockdownCat <- c()
national_lockdowns <- filter(national_lockdowns, country %in% modelData$country)
for(i in seq(1:40)){
  if(national_lockdowns[i, ]$national_lockdown_length < 48){
    lockdownCat <- c(lockdownCat, "Short")
  }
  else if(national_lockdowns[i, ]$national_lockdown_length > 78){
    lockdownCat <- c(lockdownCat, "Long")
  }
  else{
    lockdownCat <- c(lockdownCat, "Medium")
  }
}
national_lockdowns <- national_lockdowns %>%mutate(lockdownCategory = lockdownCat)
#adds national_lockdowns data to modelData
modelData <- left_join(modelData, national_lockdowns, by = "country")
#gets rid of the Place column, it was causing probblems with stepwise regression and is basically useless here
modelData$Place <- NULL
```


```{r}

initialModel <- glm(data = modelData, rolling_gcmr_retail ~ national_lockdown_length)
summary(initialModel)
#A minimal and maximal model we want to consider, haven't yet considered interactions between variables
minModel <- glm(data = modelData, rolling_gcmr_retail ~ 1)
maxModel <- glm(data = modelData, rolling_gcmr_retail ~ gdp_capita + average_temperature + national_lockdown_length)
#stepwise regression backwards, forwards and both directions
autoBack <- step(maxModel, direction = "backward", scope = list("lower" = minModel))
autoForward <- step(minModel, direction = "forward", scope = list("upper" = maxModel))
autoBoth <- step(minModel, direction = "both", scope = list("lower" = minModel, "upper" = maxModel))
summary(autoBack)
summary(autoForward)
summary(autoBoth)
#Forward, backward and both directions stepwise regression all choose the same model which is encouraging
```

##Investigating lockdown recovery


```{r recovery}
source_url("https://raw.github.com/timleeman/ST344GroupProject/main/getdata.R")
covidData$date = as.Date(parse_date_time(covidData$date,orders=c("y","ym","ymd")))

firstdiff <- function(x) {
  shifted <- c(0,x[1:(length(x)-1)])
  result = x-shifted
  which_negative = which(result<0)
  result[which_negative] = NA
  return(result) }
covidData <- covidData %>%
  mutate(daily_confirmed = firstdiff(confirmed))

TidyData <- covidData %>% group_by(country) 
TidyData <- mutate(TidyData, country = factor(country), continent = factor(continent))

national_lockdowns <- auravisionData %>% filter(Level== "National") %>% select(-Level)
national_lockdowns <- national_lockdowns %>% mutate(national_lockdown_length = as.numeric(-difftime(`Start date`, `End date`)))
colnames(national_lockdowns)[1] = "country"
head(national_lockdowns,60)
```



```{r }

###
#rearranging so day 0 is the end of each country's respective lockdowns
#Also adding columns for moving averages of gcmr retail/recreation, grocery/pharmacy and daily confirmed cases
###


selectData <- filter(covidData, country %in% chosenCountries)
#Function to select country
lockdown_start_date <- function(cou){
  a <- national_lockdowns %>% filter(country == cou) %>% select(`Start date`)
  return(a$`Start date`[1]) 
}
lockdown_end_date <- function(cou){
  a <- national_lockdowns %>% filter(country == cou) %>% select(`End date`)
  return(a$`End date`[1]) 
}

get_lockdown_data <- function(cou){
  lockdown_data <- selectData %>% filter(country == cou) %>% 
    filter(date >= lockdown_end_date(cou))  %>%
    mutate(days_out_lockdown = as.numeric(-difftime(lockdown_end_date(cou), date)/86400),
                           rolling_gcmr_retail = zoo::rollmean(gcmr_retail_recreation, k = 7, fill = NA),
                           rolling_gcmr_grocery = zoo::rollmean(gcmr_grocery_pharmacy, k = 7, fill = NA), rolling_dc = zoo::rollmean(daily_confirmed, k = 7, fill = NA))
  return(lockdown_data)
}



lockdown_data <- data_frame()
for(cou in national_lockdowns$country){
  a <- get_lockdown_data(cou)
  lockdown_data <- rbind(a, lockdown_data)
}

lockdown_data <- left_join(lockdown_data, national_lockdowns, by = "country")
```

```{r }

###
# plotting (rolling) gcmr recovery with gradient based on total length - (just retail/recreation)
#quick model which we disregard
###

ggplot(lockdown_data, aes(x=days_out_lockdown, y= rolling_gcmr_retail, group= country)) +
  geom_line(aes(colour = lockdown_data$national_lockdown_length ))+scale_colour_gradient(low = "yellow", high = "blue")+
  labs( x = "Days out of lockdown", y = "GCMR retail/recreation")

model1 <- lm(data= lockdown_data, rolling_gcmr_retail ~ days_out_lockdown)
summary(model1)

```

```{r }

###
# Adding average temp for use as a possible explanatory variable
# Creating datafram with the relevant explanatory variables for modelling
###


average_temperature <- import("https://raw.github.com/timleeman/ST344GroupProject/main/Modelling/average_temperature_edit.xlsx")
modelData <- lockdown_data %>% select(country, daily_confirmed, date, continent, gdp_capita, gcmr_retail_recreation, gcmr_grocery_pharmacy, days_out_lockdown, income, national_lockdown_length, rolling_gcmr_retail,rolling_gcmr_grocery, population, rolling_dc) %>%  distinct()
modelData <- left_join(modelData, average_temperature, by= "country")
modelData$gdp_capita <- scale(modelData$gdp_capita)
```

```{r }

### 
#Modeling rolling average of retail/recreation gcmr with some explanatory variables
#What can be concluded of the results?
#Model chooses average temp, lockdown length and days out of lockdown as variables. Intuitively the only coefficient that does not make sense is the average temperature. Also has the largest effect so may need to reconsider.
###
modelData <- na.omit(modelData)

minModel <- glm(data = modelData, rolling_gcmr_retail ~ 1)
maxModel <- glm(data = modelData, rolling_gcmr_retail ~ gdp_capita + days_out_lockdown  + national_lockdown_length + average_temperature)
#stepwise regression backwards, forwards and both directions
autoBack <- step(maxModel, direction = "backward", scope = list("lower" = minModel))
autoForward <- step(minModel, direction = "forward", scope = list("upper" = maxModel))
autoBoth <- step(minModel, direction = "both", scope = list("lower" = minModel, "upper" = maxModel))
summary(autoBack)
summary(autoForward)
summary(autoBoth)

##Forward, backward and both directions stepwise regression all choose the same model which is encouraging
#similar
#Exhaustive search for best model

install.packages("leaps")

library(tidyverse)
library(caret)
library(leaps)

regsubsetsOut <- regsubsets(gcmr_retail_recreation ~ gdp_capita + days_out_lockdown + 
                              national_lockdown_length, data = modelData)
plot(regsubsetsOut, scale = "Cp")

```



```{r }


```

```{r }

###
#Quick plot of daily confirmed against days out of lockdown
###


ggplot(modelData, aes(x=days_out_lockdown, y= daily_confirmed, group= country)) +
  geom_line()+
  labs( x = "Days out of lockdown", y = "Daily confirmed deaths")

```

```{r }

###
#Adding per capita rolling daily cases to our modeling data
#quick plot
###



modelData <- modelData %>% mutate(dc_percapita = rolling_dc*(1/population))

ggplot(modelData, aes(x=days_out_lockdown, y= dc_percapita, group= country)) +
  geom_line()+
  labs( x = "Days out of lockdown", y = "Daily confirmed cases per capita")

```


```{r }
###
#Modelling now with rolling daily cases per capita
#Model uses all explanatory variables afforded to it. 
#Coefficients for lockdown length and days out of lockdown seem to be most important
###
modelData <- na.omit(modelData)

minModel <- glm(data = modelData, dc_percapita ~ 1)
maxModel <- glm(data = modelData, dc_percapita ~ gdp_capita + days_out_lockdown  + national_lockdown_length + average_temperature)
#stepwise regression backwards, forwards and both directions
autoBack <- step(maxModel, direction = "backward", scope = list("lower" = minModel))
autoForward <- step(minModel, direction = "forward", scope = list("upper" = maxModel))
autoBoth <- step(minModel, direction = "both", scope = list("lower" = minModel, "upper" = maxModel))
summary(autoBack)
summary(autoForward)
summary(autoBoth)

##Forward, backward and both directions stepwise regression all choose the same model which is encouraging
#similar
#Exhaustive search for best model

install.packages("leaps")

library(tidyverse)
library(caret)
library(leaps)

regsubsetsOut <- regsubsets(gcmr_retail_recreation ~ gdp_capita + days_out_lockdown + 
                              national_lockdown_length, data = modelData)
plot(regsubsetsOut, scale = "Cp")

```


